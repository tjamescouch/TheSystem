"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HNSW = void 0;
const heap_1 = require("./heap");
const node_1 = require("./node");
const similarity_1 = require("./similarity");
class HNSW {
    /**
     * Creates an in-memory HNSW index.
     */
    constructor(M = 16, efConstruction = 200, d = null, metric = 'cosine', efSearch) {
        this.d = null; // Dimension of the vectors
        this.metric = metric;
        this.d = d;
        this.M = M;
        this.efConstruction = efConstruction;
        // Default efSearch to efConstruction for backward compatibility
        this.efSearch = efSearch !== null && efSearch !== void 0 ? efSearch : efConstruction;
        this.entryPointId = -1;
        this.nodes = new Map();
        this.probs = this.set_probs(M, 1 / Math.log(M));
        this.levelMax = -1;
        this.similarityFunction = this.getMetric(metric);
    }
    getMetric(metric) {
        if (metric === 'cosine') {
            return similarity_1.cosineSimilarity;
        }
        else if (metric === 'euclidean') {
            return similarity_1.euclideanSimilarity;
        }
        else {
            throw new Error('Invalid metric');
        }
    }
    set_probs(M, levelMult) {
        let level = 0;
        const probs = [];
        while (true) {
            const prob = Math.exp(-level / levelMult) * (1 - Math.exp(-1 / levelMult));
            if (prob < 1e-9)
                break;
            probs.push(prob);
            level++;
        }
        return probs;
    }
    selectLevel() {
        let r = Math.random();
        for (let i = 0; i < this.probs.length; i++) {
            const p = this.probs[i];
            if (r < p) {
                return i;
            }
            r -= p;
        }
        return this.probs.length - 1;
    }
    greedySearch(query, entryNode, level) {
        var _a;
        let bestNode = entryNode;
        let bestScore = this.similarityFunction(query, entryNode.vector);
        let improved = true;
        while (improved) {
            improved = false;
            const neighbors = (_a = bestNode.neighbors[level]) !== null && _a !== void 0 ? _a : [];
            for (const neighborId of neighbors) {
                const neighborNode = this.nodes.get(neighborId);
                const similarity = this.similarityFunction(query, neighborNode.vector);
                if (similarity > bestScore) {
                    bestScore = similarity;
                    bestNode = neighborNode;
                    improved = true;
                }
            }
        }
        return bestNode;
    }
    searchLayer(query, entryNode, level, ef) {
        var _a, _b, _c;
        const visited = new Set([entryNode.id]);
        const candidates = new heap_1.BinaryHeap((a, b) => a.score - b.score);
        const best = new heap_1.BinaryHeap((a, b) => b.score - a.score);
        const entryScore = this.similarityFunction(query, entryNode.vector);
        candidates.push({ node: entryNode, score: entryScore });
        best.push({ node: entryNode, score: entryScore });
        while (candidates.size > 0) {
            const current = candidates.pop();
            const worstBest = best.peek();
            if (worstBest && best.size >= ef && current.score < worstBest.score) {
                break;
            }
            const neighbors = (_a = current.node.neighbors[level]) !== null && _a !== void 0 ? _a : [];
            for (const neighborId of neighbors) {
                if (visited.has(neighborId))
                    continue;
                visited.add(neighborId);
                const neighborNode = this.nodes.get(neighborId);
                const score = this.similarityFunction(query, neighborNode.vector);
                if (best.size < ef || score > ((_c = (_b = best.peek()) === null || _b === void 0 ? void 0 : _b.score) !== null && _c !== void 0 ? _c : -Infinity)) {
                    candidates.push({ node: neighborNode, score });
                    best.push({ node: neighborNode, score });
                    if (best.size > ef) {
                        best.pop();
                    }
                }
            }
        }
        return best
            .values()
            .sort((a, b) => b.score - a.score)
            .map((entry) => entry.node);
    }
    connectNodeAtLevel(node, candidates, level) {
        const selected = this.selectNeighborsHeuristic(node, candidates, this.M);
        for (const neighbor of selected) {
            this.addBidirectionalConnection(node, neighbor, level);
        }
    }
    addBidirectionalConnection(node, other, level) {
        const removedFromNode = this.insertNeighbor(node, other.id, level);
        const removedFromOther = this.insertNeighbor(other, node.id, level);
        this.removeReciprocalLinks(node, removedFromNode, level);
        this.removeReciprocalLinks(other, removedFromOther, level);
    }
    removeReciprocalLinks(node, removedIds, level) {
        var _a;
        for (const removedId of removedIds) {
            const removedNode = this.nodes.get(removedId);
            if (!removedNode)
                continue;
            removedNode.neighbors[level] = ((_a = removedNode.neighbors[level]) !== null && _a !== void 0 ? _a : []).filter((id) => id !== node.id);
        }
    }
    insertNeighbor(node, neighborId, level) {
        if (!node.neighbors[level]) {
            node.neighbors[level] = [];
        }
        const existingIds = node.neighbors[level].filter((id) => id !== neighborId);
        const candidateIds = [...existingIds, neighborId];
        const candidateNodes = candidateIds
            .map((id) => this.nodes.get(id))
            .filter((candidate) => Boolean(candidate));
        const selected = this.selectNeighborsHeuristic(node, candidateNodes, this.M);
        const selectedIds = selected.map((selectedNode) => selectedNode.id);
        const removedIds = existingIds.filter((id) => !selectedIds.includes(id));
        node.neighbors[level] = selectedIds;
        return removedIds;
    }
    selectNeighborsHeuristic(node, candidates, maxNeighbors) {
        const uniqueCandidates = new Map();
        for (const candidate of candidates) {
            if (candidate.id === node.id)
                continue;
            uniqueCandidates.set(candidate.id, candidate);
        }
        const scored = Array.from(uniqueCandidates.values())
            .map((candidate) => ({
            node: candidate,
            score: this.similarityFunction(node.vector, candidate.vector),
        }))
            .sort((a, b) => b.score - a.score);
        const selected = [];
        for (const entry of scored) {
            if (selected.length >= maxNeighbors) {
                break;
            }
            const shouldSelect = selected.every((neighbor) => {
                const neighborSimilarity = this.similarityFunction(entry.node.vector, neighbor.vector);
                return neighborSimilarity <= entry.score;
            });
            if (shouldSelect) {
                selected.push(entry.node);
            }
        }
        return selected;
    }
    addNodeToGraph(node) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.entryPointId === -1) {
                this.entryPointId = node.id;
                this.levelMax = node.level;
                return;
            }
            const currentMaxLevel = this.levelMax;
            let entryNode = this.nodes.get(this.entryPointId);
            for (let level = currentMaxLevel; level > node.level; level--) {
                entryNode = this.greedySearch(node.vector, entryNode, level);
            }
            const targetLevel = Math.min(node.level, currentMaxLevel);
            for (let level = targetLevel; level >= 0; level--) {
                const neighbors = this.searchLayer(node.vector, entryNode, level, this.efConstruction);
                this.connectNodeAtLevel(node, neighbors, level);
                if (neighbors.length > 0) {
                    entryNode = neighbors[0];
                }
            }
            if (node.level > this.levelMax) {
                this.entryPointId = node.id;
                this.levelMax = node.level;
            }
        });
    }
    /**
     * Adds a single vector to the graph.
     */
    addPoint(id, vector) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.d !== null && vector.length !== this.d) {
                throw new Error('All vectors must be of the same dimension');
            }
            this.d = vector.length;
            if (this.nodes.has(id)) {
                throw new Error(`Node with id ${id} already exists`);
            }
            this.nodes.set(id, new node_1.Node(id, vector, this.selectLevel()));
            const node = this.nodes.get(id);
            yield this.addNodeToGraph(node);
        });
    }
    /**
     * Returns up to k nearest neighbors for the query vector.
     */
    searchKNN(query, k, options) {
        var _a;
        if (this.entryPointId === -1 || this.nodes.size === 0 || k <= 0) {
            return [];
        }
        let entryNode = this.nodes.get(this.entryPointId);
        for (let level = this.levelMax; level > 0; level--) {
            entryNode = this.greedySearch(query, entryNode, level);
        }
        const ef = Math.max(k, (_a = options === null || options === void 0 ? void 0 : options.efSearch) !== null && _a !== void 0 ? _a : this.efSearch);
        const candidates = this.searchLayer(query, entryNode, 0, ef);
        const results = [];
        const seen = new Set();
        for (const node of candidates) {
            if (seen.has(node.id))
                continue;
            seen.add(node.id);
            const score = this.similarityFunction(node.vector, query);
            results.push({ id: node.id, score });
            if (results.length === k) {
                break;
            }
        }
        return results;
    }
    /**
     * Rebuilds the graph from the provided data.
     */
    buildIndex(data, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Clear existing index
            this.nodes.clear();
            this.levelMax = -1;
            this.entryPointId = -1;
            this.d = null;
            const total = data.length;
            const interval = (_a = options === null || options === void 0 ? void 0 : options.progressInterval) !== null && _a !== void 0 ? _a : 10000;
            const onProgress = options === null || options === void 0 ? void 0 : options.onProgress;
            // Add points to the index
            for (let i = 0; i < data.length; i++) {
                yield this.addPoint(data[i].id, data[i].vector);
                if (onProgress && (i + 1) % interval === 0) {
                    onProgress(i + 1, total);
                }
            }
            // Final progress call
            if (onProgress && total % interval !== 0) {
                onProgress(total, total);
            }
        });
    }
    /**
     * Serializes the current in-memory index.
     */
    toJSON() {
        const entries = Array.from(this.nodes.entries());
        return {
            M: this.M,
            efConstruction: this.efConstruction,
            efSearch: this.efSearch,
            metric: this.metric,
            d: this.d,
            levelMax: this.levelMax,
            entryPointId: this.entryPointId,
            nodes: entries.map(([id, node]) => {
                return [
                    id,
                    {
                        id: node.id,
                        level: node.level,
                        vector: Array.from(node.vector),
                        neighbors: node.neighbors.map((level) => Array.from(level)),
                    },
                ];
            }),
        };
    }
    /**
     * Restores an index from serialized JSON produced by toJSON().
     */
    static fromJSON(json) {
        var _a, _b;
        // efSearch defaults to efConstruction if not present (backward compatibility)
        const hnsw = new HNSW(json.M, json.efConstruction, (_a = json.d) !== null && _a !== void 0 ? _a : null, (_b = json.metric) !== null && _b !== void 0 ? _b : 'cosine', json.efSearch);
        hnsw.levelMax = json.levelMax;
        hnsw.entryPointId = json.entryPointId;
        hnsw.nodes = new Map(json.nodes.map(([id, node]) => {
            const restored = new node_1.Node(node.id, new Float32Array(node.vector), node.level);
            restored.neighbors = node.neighbors.map((level) => [...level]);
            return [id, restored];
        }));
        return hnsw;
    }
}
exports.HNSW = HNSW;
