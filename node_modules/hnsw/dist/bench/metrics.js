"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.meanRecall = exports.summarizeLatencies = exports.percentile = exports.average = exports.recallAtK = exports.bruteForceKNN = void 0;
function bruteForceKNN(query, vectors, similarity, k) {
    if (k <= 0)
        return [];
    const scored = vectors.map((entry) => ({
        id: entry.id,
        score: similarity(query, entry.vector),
    }));
    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, Math.min(k, scored.length));
}
exports.bruteForceKNN = bruteForceKNN;
function recallAtK(approx, exact, k) {
    if (k <= 0) {
        return { recall: 0, hits: 0, total: 0 };
    }
    const topApprox = new Set(approx.slice(0, k).map((item) => item.id));
    const topExact = exact.slice(0, k);
    let hits = 0;
    for (const item of topExact) {
        if (topApprox.has(item.id)) {
            hits++;
        }
    }
    const total = topExact.length;
    const recall = total === 0 ? 0 : hits / total;
    return { recall, hits, total };
}
exports.recallAtK = recallAtK;
function average(values) {
    if (values.length === 0)
        return 0;
    return values.reduce((sum, value) => sum + value, 0) / values.length;
}
exports.average = average;
function percentile(values, p) {
    if (values.length === 0)
        return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const clamped = Math.max(0, Math.min(100, p));
    const index = Math.floor((clamped / 100) * (sorted.length - 1));
    return sorted[index];
}
exports.percentile = percentile;
function summarizeLatencies(latenciesMs) {
    return {
        count: latenciesMs.length,
        avg: average(latenciesMs),
        p50: percentile(latenciesMs, 50),
        p90: percentile(latenciesMs, 90),
        p95: percentile(latenciesMs, 95),
        p99: percentile(latenciesMs, 99),
    };
}
exports.summarizeLatencies = summarizeLatencies;
function meanRecall(results) {
    if (results.length === 0)
        return 0;
    const totalHits = results.reduce((sum, result) => sum + result.hits, 0);
    const total = results.reduce((sum, result) => sum + result.total, 0);
    return total === 0 ? 0 : totalHits / total;
}
exports.meanRecall = meanRecall;
