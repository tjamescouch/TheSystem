"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const main_1 = require("../main");
const similarity_1 = require("../similarity");
const dataset_1 = require("./dataset");
const metrics_1 = require("./metrics");
const DEFAULT_OUTPUT_DIR = 'bench/outputs';
function parseArgs(argv) {
    var _a, _b, _c, _d;
    const get = (flag) => {
        const idx = argv.indexOf(flag);
        if (idx === -1)
            return undefined;
        return argv[idx + 1];
    };
    const getList = (flag, fallback) => {
        const raw = get(flag);
        if (!raw)
            return fallback;
        return raw
            .split(',')
            .map((value) => Number(value.trim()))
            .filter((value) => Number.isFinite(value));
    };
    const mode = (_a = get('--mode')) !== null && _a !== void 0 ? _a : 'synthetic';
    const metric = (_b = get('--metric')) !== null && _b !== void 0 ? _b : 'cosine';
    const config = {
        mode,
        metric,
        basePath: get('--base'),
        queryPath: get('--query'),
        limit: get('--limit') ? Number(get('--limit')) : undefined,
        queryLimit: get('--query-limit') ? Number(get('--query-limit')) : undefined,
        count: get('--count') ? Number(get('--count')) : undefined,
        dimension: get('--dim') ? Number(get('--dim')) : undefined,
        seed: get('--seed') ? Number(get('--seed')) : 42,
        distribution: (_c = get('--distribution')) !== null && _c !== void 0 ? _c : 'uniform',
        k: get('--k') ? Number(get('--k')) : 10,
        efSearchList: getList('--efSearch', [10, 20, 50, 100, 200]),
        mList: getList('--M', [8, 16, 32]),
        efConstructionList: getList('--efConstruction', [100, 200, 400]),
        outputDir: (_d = get('--output')) !== null && _d !== void 0 ? _d : DEFAULT_OUTPUT_DIR,
    };
    if (config.mode === 'synthetic') {
        if (!config.count || !config.dimension) {
            throw new Error('Synthetic mode requires --count and --dim.');
        }
    }
    else {
        if (!config.basePath) {
            throw new Error('Vector file mode requires --base path.');
        }
    }
    return config;
}
function getSimilarity(metric) {
    return metric === 'cosine' ? similarity_1.cosineSimilarity : similarity_1.euclideanSimilarity;
}
function loadDataset(config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (config.mode === 'synthetic') {
            const base = (0, dataset_1.generateSyntheticDataset)({
                count: config.count,
                dimension: config.dimension,
                metric: config.metric,
                seed: config.seed,
                distribution: config.distribution,
            });
            const queryCount = Math.min(100, base.vectors.length);
            const queries = base.vectors.slice(0, queryCount);
            return { base, queries };
        }
        const base = yield (0, dataset_1.loadFvecsDataset)(config.basePath, config.metric, {
            limit: config.limit,
        });
        const queries = config.queryPath
            ? (yield (0, dataset_1.loadFvecsDataset)(config.queryPath, config.metric, {
                limit: config.queryLimit,
            })).vectors
            : base.vectors.slice(0, Math.min(100, base.vectors.length));
        return { base, queries };
    });
}
function asDataRecords(vectors) {
    return vectors.map((record) => ({ id: record.id, vector: record.vector }));
}
function runBenchmark(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { base, queries } = yield loadDataset(config);
        if (base.vectors.length === 0) {
            throw new Error('Dataset contains zero vectors.');
        }
        if (queries.length === 0) {
            throw new Error('Query set is empty.');
        }
        const similarity = getSimilarity(config.metric);
        const baseData = asDataRecords(base.vectors);
        const results = [];
        for (const M of config.mList) {
            for (const efConstruction of config.efConstructionList) {
                const hnsw = new main_1.HNSW(M, efConstruction, base.dimension, config.metric);
                console.log(`Building index: M=${M}, efConstruction=${efConstruction}, vectors=${base.vectors.length}`);
                const buildStart = perf_hooks_1.performance.now();
                yield hnsw.buildIndex(baseData, {
                    progressInterval: Math.max(10000, Math.floor(base.vectors.length / 20)),
                    onProgress: (current, total) => {
                        const pct = ((current / total) * 100).toFixed(1);
                        const elapsed = ((perf_hooks_1.performance.now() - buildStart) / 1000).toFixed(1);
                        const rate = (current / ((perf_hooks_1.performance.now() - buildStart) / 1000)).toFixed(0);
                        process.stdout.write(`\r  Progress: ${current.toLocaleString()}/${total.toLocaleString()} (${pct}%) - ${elapsed}s - ${rate} vec/s`);
                    },
                });
                const buildMs = perf_hooks_1.performance.now() - buildStart;
                console.log(`\n  Build complete: ${(buildMs / 1000).toFixed(2)}s`);
                console.log(`  Computing ground truth (brute force on ${queries.length} queries)...`);
                const bruteStart = perf_hooks_1.performance.now();
                const exact = queries.map((query, i) => {
                    if ((i + 1) % 10 === 0 || i === queries.length - 1) {
                        process.stdout.write(`\r  Brute force: ${i + 1}/${queries.length} queries`);
                    }
                    return (0, metrics_1.bruteForceKNN)(query.vector, baseData, similarity, config.k);
                });
                console.log(` - ${((perf_hooks_1.performance.now() - bruteStart) / 1000).toFixed(2)}s`);
                for (const efSearch of config.efSearchList) {
                    console.log(`  Searching with efSearch=${efSearch}...`);
                    const latencies = [];
                    const recalls = [];
                    for (let i = 0; i < queries.length; i++) {
                        const query = queries[i];
                        const start = perf_hooks_1.performance.now();
                        const approx = hnsw.searchKNN(query.vector, config.k, { efSearch });
                        latencies.push(perf_hooks_1.performance.now() - start);
                        recalls.push((0, metrics_1.recallAtK)(approx, exact[i], config.k));
                    }
                    const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
                    const recall = (0, metrics_1.meanRecall)(recalls);
                    console.log(`    Recall: ${(recall * 100).toFixed(1)}%, Avg latency: ${avgLatency.toFixed(3)}ms`);
                    results.push({
                        dataset: {
                            name: base.name,
                            metric: config.metric,
                            dimension: base.dimension,
                            count: base.vectors.length,
                            queries: queries.length,
                        },
                        params: {
                            M,
                            efConstruction,
                            efSearch,
                            k: config.k,
                        },
                        buildMs,
                        searchLatencyMs: (0, metrics_1.summarizeLatencies)(latencies),
                        recallAtK: (0, metrics_1.meanRecall)(recalls),
                    });
                }
            }
        }
        return results;
    });
}
function writeResults(config, results) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, promises_1.mkdir)((0, path_1.resolve)(config.outputDir), { recursive: true });
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const datasetName = config.mode === 'synthetic' ? `synthetic-${config.count}x${config.dimension}` : (0, path_1.basename)(config.basePath);
        const filePath = (0, path_1.resolve)(config.outputDir, `bench-${datasetName}-${timestamp}.json`);
        yield (0, promises_1.writeFile)(filePath, JSON.stringify({ config, results }, null, 2), 'utf8');
        return filePath;
    });
}
function printUsage() {
    const message = `
Usage:
  node dist/bench/run.js --mode synthetic --count 10000 --dim 64 --metric cosine
  node dist/bench/run.js --mode fvecs --base ./bench/datasets/sift_base.fvecs --query ./bench/datasets/sift_query.fvecs --metric euclidean

Flags:
  --mode synthetic|fvecs
  --metric cosine|euclidean
  --base <path>           Base vectors file (fvecs)
  --query <path>          Query vectors file (optional)
  --limit <n>             Limit base vectors
  --query-limit <n>       Limit query vectors
  --count <n>             Synthetic count
  --dim <n>               Synthetic dimension
  --seed <n>              Synthetic seed
  --distribution uniform|gaussian
  --k <n>                 K for recall@k
  --efSearch <list>       Comma list, e.g. 10,50,100
  --M <list>              Comma list
  --efConstruction <list> Comma list
  --output <dir>          Output directory (default bench/outputs)
`.trim();
    console.log(message);
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const argv = process.argv.slice(2);
        if (argv.includes('--help')) {
            printUsage();
            return;
        }
        const config = parseArgs(argv);
        const results = yield runBenchmark(config);
        const outputPath = yield writeResults(config, results);
        console.log(`Saved results to ${outputPath}`);
    });
}
main().catch((error) => {
    console.error(error instanceof Error ? error.message : error);
    printUsage();
    process.exit(1);
});
