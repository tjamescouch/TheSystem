"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const path_1 = require("path");
function parseArgs(argv) {
    var _a;
    const get = (flag) => {
        const idx = argv.indexOf(flag);
        if (idx === -1)
            return undefined;
        return argv[idx + 1];
    };
    return {
        basePath: get('--base'),
        candidatePath: get('--candidate'),
        baseDir: get('--base-dir'),
        candidateDir: get('--candidate-dir'),
        output: get('--output'),
        format: (_a = get('--format')) !== null && _a !== void 0 ? _a : 'json',
        strict: argv.includes('--strict'),
    };
}
function makeKey(result) {
    const d = result.dataset;
    const p = result.params;
    return [d.name, d.metric, d.dimension, d.count, d.queries, p.M, p.efConstruction, p.efSearch, p.k].join('|');
}
function summarizeDelta(values) {
    if (values.length === 0)
        return { avg: 0, min: 0, max: 0 };
    const avg = values.reduce((sum, v) => sum + v, 0) / values.length;
    const min = Math.min(...values);
    const max = Math.max(...values);
    return { avg, min, max };
}
function readBenchmarkFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const raw = yield (0, promises_1.readFile)(filePath, 'utf8');
        const parsed = JSON.parse(raw);
        if (!(parsed === null || parsed === void 0 ? void 0 : parsed.results) || !Array.isArray(parsed.results)) {
            throw new Error(`Invalid benchmark file: ${filePath}`);
        }
        return parsed;
    });
}
function loadFromDir(dirPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const { readdir } = yield Promise.resolve().then(() => __importStar(require('fs/promises')));
        const entries = yield readdir(dirPath, { withFileTypes: true });
        const files = entries
            .filter((entry) => entry.isFile() && entry.name.endsWith('.json'))
            .map((entry) => (0, path_1.resolve)(dirPath, entry.name));
        const results = [];
        for (const file of files) {
            const data = yield readBenchmarkFile(file);
            results.push(...data.results);
        }
        return results;
    });
}
function compareResults(base, candidate, strict) {
    const baseMap = new Map();
    const candidateMap = new Map();
    for (const item of base) {
        baseMap.set(makeKey(item), item);
    }
    for (const item of candidate) {
        candidateMap.set(makeKey(item), item);
    }
    const allKeys = new Set([...baseMap.keys(), ...candidateMap.keys()]);
    const rows = [];
    const missingInBase = [];
    const missingInCandidate = [];
    for (const key of allKeys) {
        const baseItem = baseMap.get(key);
        const candItem = candidateMap.get(key);
        if (!baseItem) {
            missingInBase.push(key);
            if (strict)
                continue;
        }
        if (!candItem) {
            missingInCandidate.push(key);
            if (strict)
                continue;
        }
        if (!baseItem || !candItem)
            continue;
        rows.push({
            key,
            datasetName: baseItem.dataset.name,
            metric: baseItem.dataset.metric,
            dimension: baseItem.dataset.dimension,
            count: baseItem.dataset.count,
            queries: baseItem.dataset.queries,
            M: baseItem.params.M,
            efConstruction: baseItem.params.efConstruction,
            efSearch: baseItem.params.efSearch,
            k: baseItem.params.k,
            recallBase: baseItem.recallAtK,
            recallCandidate: candItem.recallAtK,
            recallDelta: candItem.recallAtK - baseItem.recallAtK,
            latencyAvgBase: baseItem.searchLatencyMs.avg,
            latencyAvgCandidate: candItem.searchLatencyMs.avg,
            latencyAvgDelta: candItem.searchLatencyMs.avg - baseItem.searchLatencyMs.avg,
            latencyP95Base: baseItem.searchLatencyMs.p95,
            latencyP95Candidate: candItem.searchLatencyMs.p95,
            latencyP95Delta: candItem.searchLatencyMs.p95 - baseItem.searchLatencyMs.p95,
            buildMsBase: baseItem.buildMs,
            buildMsCandidate: candItem.buildMs,
            buildMsDelta: candItem.buildMs - baseItem.buildMs,
        });
    }
    return { rows, missingInBase, missingInCandidate };
}
function toCsv(rows) {
    const header = [
        'datasetName',
        'metric',
        'dimension',
        'count',
        'queries',
        'M',
        'efConstruction',
        'efSearch',
        'k',
        'recallBase',
        'recallCandidate',
        'recallDelta',
        'latencyAvgBase',
        'latencyAvgCandidate',
        'latencyAvgDelta',
        'latencyP95Base',
        'latencyP95Candidate',
        'latencyP95Delta',
        'buildMsBase',
        'buildMsCandidate',
        'buildMsDelta',
    ];
    const lines = [header.join(',')];
    for (const row of rows) {
        lines.push([
            row.datasetName,
            row.metric,
            row.dimension,
            row.count,
            row.queries,
            row.M,
            row.efConstruction,
            row.efSearch,
            row.k,
            row.recallBase.toFixed(6),
            row.recallCandidate.toFixed(6),
            row.recallDelta.toFixed(6),
            row.latencyAvgBase.toFixed(6),
            row.latencyAvgCandidate.toFixed(6),
            row.latencyAvgDelta.toFixed(6),
            row.latencyP95Base.toFixed(6),
            row.latencyP95Candidate.toFixed(6),
            row.latencyP95Delta.toFixed(6),
            row.buildMsBase.toFixed(3),
            row.buildMsCandidate.toFixed(3),
            row.buildMsDelta.toFixed(3),
        ].join(','));
    }
    return lines.join('\n');
}
function printSummary(rows) {
    const recallDeltas = rows.map((r) => r.recallDelta);
    const latencyAvgDeltas = rows.map((r) => r.latencyAvgDelta);
    const latencyP95Deltas = rows.map((r) => r.latencyP95Delta);
    const buildDeltas = rows.map((r) => r.buildMsDelta);
    const recallStats = summarizeDelta(recallDeltas);
    const latencyAvgStats = summarizeDelta(latencyAvgDeltas);
    const latencyP95Stats = summarizeDelta(latencyP95Deltas);
    const buildStats = summarizeDelta(buildDeltas);
    console.log('Summary (candidate - base):');
    console.log(`  recall@k  avg=${recallStats.avg.toFixed(6)} min=${recallStats.min.toFixed(6)} max=${recallStats.max.toFixed(6)}`);
    console.log(`  latencyAvg ms  avg=${latencyAvgStats.avg.toFixed(6)} min=${latencyAvgStats.min.toFixed(6)} max=${latencyAvgStats.max.toFixed(6)}`);
    console.log(`  latencyP95 ms  avg=${latencyP95Stats.avg.toFixed(6)} min=${latencyP95Stats.min.toFixed(6)} max=${latencyP95Stats.max.toFixed(6)}`);
    console.log(`  buildMs  avg=${buildStats.avg.toFixed(3)} min=${buildStats.min.toFixed(3)} max=${buildStats.max.toFixed(3)}`);
}
function printUsage() {
    const message = `
Usage:
  node dist/bench/report.js --base <file> --candidate <file> [--format json|csv] [--output <path>]
  node dist/bench/report.js --base-dir <dir> --candidate-dir <dir> [--format json|csv] [--output <path>]

Options:
  --base <file>           Baseline JSON file from bench outputs
  --candidate <file>      Candidate JSON file from bench outputs
  --base-dir <dir>        Directory of baseline JSON files
  --candidate-dir <dir>   Directory of candidate JSON files
  --format json|csv       Output format (default json)
  --output <path>         Write report to file (prints summary to stdout)
  --strict                Only compare keys present in both base and candidate

Examples:
  node dist/bench/report.js --base bench/outputs/base.json --candidate bench/outputs/new.json --format csv --output bench/outputs/compare.csv
  node dist/bench/report.js --base-dir bench/outputs/base --candidate-dir bench/outputs/new
`.trim();
    console.log(message);
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const argv = process.argv.slice(2);
        if (argv.includes('--help')) {
            printUsage();
            return;
        }
        const config = parseArgs(argv);
        let baseResults = [];
        let candidateResults = [];
        if (config.basePath && config.candidatePath) {
            const baseFile = yield readBenchmarkFile(config.basePath);
            const candidateFile = yield readBenchmarkFile(config.candidatePath);
            baseResults = baseFile.results;
            candidateResults = candidateFile.results;
        }
        else if (config.baseDir && config.candidateDir) {
            baseResults = yield loadFromDir(config.baseDir);
            candidateResults = yield loadFromDir(config.candidateDir);
        }
        else {
            printUsage();
            process.exit(1);
        }
        const { rows, missingInBase, missingInCandidate } = compareResults(baseResults, candidateResults, config.strict);
        printSummary(rows);
        if (missingInBase.length > 0) {
            console.log(`Missing in base (${missingInBase.length}):`);
            console.log(missingInBase.map((key) => `  ${key}`).join('\n'));
        }
        if (missingInCandidate.length > 0) {
            console.log(`Missing in candidate (${missingInCandidate.length}):`);
            console.log(missingInCandidate.map((key) => `  ${key}`).join('\n'));
        }
        if (config.output) {
            const outputPath = (0, path_1.resolve)(config.output);
            const payload = config.format === 'csv' ? toCsv(rows) : JSON.stringify({ rows, missingInBase, missingInCandidate }, null, 2);
            yield (0, promises_1.writeFile)(outputPath, payload, 'utf8');
            console.log(`Report written to ${outputPath}`);
        }
    });
}
main().catch((err) => {
    console.error(err instanceof Error ? err.message : err);
    printUsage();
    process.exit(1);
});
