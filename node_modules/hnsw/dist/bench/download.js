"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const promises_1 = require("stream/promises");
const https_1 = require("https");
const child_process_1 = require("child_process");
const DEFAULT_URL = 'https://huggingface.co/datasets/vecdata/siftsmall/resolve/main/siftsmall.tar.gz?download=true';
const DEFAULT_OUT_DIR = 'bench/datasets';
function parseArgs(argv) {
    var _a, _b;
    const get = (flag) => {
        const idx = argv.indexOf(flag);
        if (idx === -1)
            return undefined;
        return argv[idx + 1];
    };
    return {
        url: (_a = get('--url')) !== null && _a !== void 0 ? _a : DEFAULT_URL,
        outDir: (_b = get('--out')) !== null && _b !== void 0 ? _b : DEFAULT_OUT_DIR,
        filename: get('--name'),
        extract: argv.includes('--extract'),
        skipIfExists: argv.includes('--skip-if-exists'),
        timeoutMs: get('--timeout') ? Number(get('--timeout')) : 30000,
    };
}
function downloadFile(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, outDir, filename, skipIfExists = true, timeoutMs = 30000 } = options;
        (0, fs_1.mkdirSync)(outDir, { recursive: true });
        const finalName = filename !== null && filename !== void 0 ? filename : ((0, path_1.basename)(new URL(url).pathname) || 'dataset.tar.gz');
        const outputPath = (0, path_1.resolve)(outDir, finalName);
        if (skipIfExists && (0, fs_1.existsSync)(outputPath)) {
            const stats = (0, fs_1.statSync)(outputPath);
            if (stats.size > 0) {
                console.log(`File already exists: ${outputPath}`);
                return outputPath;
            }
        }
        console.log(`Downloading ${url}`);
        console.log(`â†’ ${outputPath}`);
        yield new Promise((resolvePromise, rejectPromise) => {
            const req = (0, https_1.request)(url, { timeout: timeoutMs }, (res) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                    // follow redirect - resolve relative URLs against the original
                    res.resume();
                    try {
                        const redirectUrl = new URL(res.headers.location, url).toString();
                        const redirected = yield downloadFile(Object.assign(Object.assign({}, options), { url: redirectUrl, filename: finalName }));
                        resolvePromise();
                    }
                    catch (err) {
                        rejectPromise(err);
                    }
                    return;
                }
                if (res.statusCode !== 200) {
                    rejectPromise(new Error(`Download failed with status ${res.statusCode}`));
                    res.resume();
                    return;
                }
                const total = Number((_a = res.headers['content-length']) !== null && _a !== void 0 ? _a : 0);
                let received = 0;
                res.on('data', (chunk) => {
                    received += chunk.length;
                    if (total > 0) {
                        const pct = ((received / total) * 100).toFixed(1);
                        process.stdout.write(`\r${pct}% (${received}/${total} bytes)`);
                    }
                    else {
                        process.stdout.write(`\r${received} bytes`);
                    }
                });
                const fileStream = (0, fs_1.createWriteStream)(outputPath);
                try {
                    yield (0, promises_1.pipeline)(res, fileStream);
                    process.stdout.write('\n');
                    resolvePromise();
                }
                catch (err) {
                    rejectPromise(err);
                }
            }));
            req.on('error', rejectPromise);
            req.on('timeout', () => {
                req.destroy(new Error('Request timed out'));
            });
            req.end();
        });
        return outputPath;
    });
}
function extractTarGz(archivePath, outDir) {
    return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((resolvePromise, rejectPromise) => {
            const proc = (0, child_process_1.spawn)('tar', ['-xzf', archivePath, '-C', outDir], { stdio: 'inherit' });
            proc.on('error', rejectPromise);
            proc.on('close', (code) => {
                if (code === 0)
                    resolvePromise();
                else
                    rejectPromise(new Error(`tar exited with code ${code}`));
            });
        });
    });
}
function printUsage() {
    const text = `
Usage:
  node dist/bench/download.js [--url <url>] [--out <dir>] [--name <filename>] [--extract] [--skip-if-exists]

Defaults:
  --url  ${DEFAULT_URL}
  --out  ${DEFAULT_OUT_DIR}

Examples:
  node dist/bench/download.js --extract
  node dist/bench/download.js --url ${DEFAULT_URL} --out bench/datasets --extract
`.trim();
    console.log(text);
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const argv = process.argv.slice(2);
        if (argv.includes('--help')) {
            printUsage();
            return;
        }
        const config = parseArgs(argv);
        const archivePath = yield downloadFile({
            url: config.url,
            outDir: config.outDir,
            filename: config.filename,
            skipIfExists: config.skipIfExists,
            timeoutMs: config.timeoutMs,
        });
        if (config.extract) {
            console.log(`Extracting ${archivePath}`);
            yield extractTarGz(archivePath, config.outDir);
        }
    });
}
main().catch((err) => {
    console.error(err instanceof Error ? err.message : err);
    printUsage();
    process.exit(1);
});
