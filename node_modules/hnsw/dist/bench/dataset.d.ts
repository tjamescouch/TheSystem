/// <reference types="node" />
/// <reference types="node" />
export type VectorRecord = {
    id: number;
    vector: Float32Array;
};
export type Dataset = {
    name: string;
    dimension: number;
    metric: 'cosine' | 'euclidean';
    vectors: VectorRecord[];
};
export type FVecsLoadOptions = {
    limit?: number;
    offset?: number;
    asFloat32?: boolean;
};
export type SyntheticOptions = {
    name?: string;
    count: number;
    dimension: number;
    metric: 'cosine' | 'euclidean';
    seed?: number;
    distribution?: 'uniform' | 'gaussian';
};
export declare function generateSyntheticDataset(options: SyntheticOptions): Dataset;
export declare function loadFvecsDataset(filePath: string, metric: 'cosine' | 'euclidean', options?: FVecsLoadOptions): Promise<Dataset>;
export declare function readFvecs(filePath: string, options?: FVecsLoadOptions): Promise<VectorRecord[]>;
export declare function decodeFvecsBuffer(buffer: Buffer, options?: FVecsLoadOptions): VectorRecord[];
export declare function loadIvecsAsFloatDataset(filePath: string, metric: 'cosine' | 'euclidean', options?: FVecsLoadOptions): Promise<Dataset>;
export declare function readIvecsAsFloat(filePath: string, options?: FVecsLoadOptions): Promise<VectorRecord[]>;
export declare function decodeIvecsAsFloatBuffer(buffer: Buffer, options?: FVecsLoadOptions): VectorRecord[];
export declare function streamFvecs(filePath: string, onVector: (record: VectorRecord) => Promise<void> | void, options?: FVecsLoadOptions): Promise<void>;
