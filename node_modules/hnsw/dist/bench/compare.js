"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
function parseArgs(argv) {
    var _a, _b, _c, _d, _e, _f, _g;
    const get = (flag) => {
        const idx = argv.indexOf(flag);
        if (idx === -1)
            return undefined;
        return argv[idx + 1];
    };
    const has = (flag) => argv.includes(flag);
    const baseRef = (_a = get('--base-ref')) !== null && _a !== void 0 ? _a : 'HEAD~1';
    const candidateRef = (_b = get('--candidate-ref')) !== null && _b !== void 0 ? _b : 'HEAD';
    const tag = get('--tag');
    const baseOut = (_c = get('--base-out')) !== null && _c !== void 0 ? _c : (0, path_1.resolve)('bench/outputs', `baseline${tag ? `-${tag}` : ''}`);
    const candidateOut = (_d = get('--candidate-out')) !== null && _d !== void 0 ? _d : (0, path_1.resolve)('bench/outputs', `candidate${tag ? `-${tag}` : ''}`);
    const reportOut = (_e = get('--report-out')) !== null && _e !== void 0 ? _e : (0, path_1.resolve)('bench/outputs', `compare${tag ? `-${tag}` : ''}.csv`);
    const reportFormat = (_f = get('--report-format')) !== null && _f !== void 0 ? _f : 'csv';
    const runScriptPathRaw = get('--bench-runner');
    const reportScriptPathRaw = get('--bench-reporter');
    const runScriptPath = (0, path_1.resolve)(runScriptPathRaw !== null && runScriptPathRaw !== void 0 ? runScriptPathRaw : 'dist/bench/run.js');
    const reportScriptPath = (0, path_1.resolve)(reportScriptPathRaw !== null && reportScriptPathRaw !== void 0 ? reportScriptPathRaw : 'dist/bench/report.js');
    const buildIfMissing = !runScriptPathRaw || !reportScriptPathRaw;
    // Default to injecting sources unless explicitly disabled
    const injectSources = !has('--no-inject-sources');
    const injectDir = (0, path_1.resolve)((_g = get('--inject-dir')) !== null && _g !== void 0 ? _g : 'bench/outputs/bench-sources');
    const passthroughFlags = [
        '--mode',
        '--metric',
        '--base',
        '--query',
        '--limit',
        '--query-limit',
        '--count',
        '--dim',
        '--seed',
        '--distribution',
        '--k',
        '--efSearch',
        '--M',
        '--efConstruction',
    ];
    const runArgs = [];
    for (const flag of passthroughFlags) {
        const value = get(flag);
        if (value !== undefined) {
            runArgs.push(flag, value);
        }
    }
    return {
        baseRef,
        candidateRef,
        baseOut,
        candidateOut,
        reportOut,
        reportFormat,
        allowDirty: has('--allow-dirty'),
        tag,
        runArgs,
        runScriptPath,
        reportScriptPath,
        buildIfMissing,
        injectSources,
        injectDir,
    };
}
function runCommand(command, args, cwd) {
    const result = (0, child_process_1.spawnSync)(command, args, {
        cwd,
        stdio: 'inherit',
        env: process.env,
    });
    if (result.status !== 0) {
        throw new Error(`Command failed: ${command} ${args.join(' ')}`);
    }
}
function runCommandCapture(command, args) {
    var _a;
    const result = (0, child_process_1.spawnSync)(command, args, {
        encoding: 'utf8',
        stdio: ['ignore', 'pipe', 'pipe'],
        env: process.env,
    });
    if (result.status !== 0) {
        throw new Error(`Command failed: ${command} ${args.join(' ')}`);
    }
    return ((_a = result.stdout) !== null && _a !== void 0 ? _a : '').trim();
}
function ensureCleanWorkingTree(allowDirty) {
    const status = runCommandCapture('git', ['status', '--porcelain']);
    if (status.length > 0 && !allowDirty) {
        throw new Error('Working tree is dirty. Commit/stash changes or pass --allow-dirty.');
    }
}
function getCurrentRef() {
    const ref = runCommandCapture('git', ['rev-parse', '--abbrev-ref', 'HEAD']);
    if (ref === 'HEAD') {
        return runCommandCapture('git', ['rev-parse', 'HEAD']);
    }
    return ref;
}
function checkout(ref) {
    runCommand('git', ['checkout', ref]);
}
function build() {
    runCommand('npm', ['run', 'build']);
}
function runBench(runScriptPath, runArgs, outputDir) {
    const args = [runScriptPath, ...runArgs, '--output', outputDir];
    runCommand('node', args);
}
function runReport(reportScriptPath, baseDir, candidateDir, outputPath, format) {
    const args = [reportScriptPath, '--base-dir', baseDir, '--candidate-dir', candidateDir, '--format', format];
    if (outputPath) {
        args.push('--output', outputPath);
    }
    runCommand('node', args);
}
function ensureDistExists(runPath, reportPath, buildIfMissing) {
    const downloadPath = (0, path_1.resolve)('dist/bench/download.js');
    if ((!(0, fs_1.existsSync)(runPath) || !(0, fs_1.existsSync)(reportPath)) && buildIfMissing) {
        build();
    }
    if (!(0, fs_1.existsSync)(runPath) || !(0, fs_1.existsSync)(reportPath)) {
        throw new Error(`Benchmark runner scripts not found: ${runPath} or ${reportPath}`);
    }
    if (!(0, fs_1.existsSync)(downloadPath)) {
        // download script is optional for comparison flow
    }
}
function getTrackedBenchFiles() {
    const output = runCommandCapture('git', ['ls-files', 'src/bench']);
    if (!output)
        return new Set();
    return new Set(output
        .split('\n')
        .map((line) => line.trim())
        .filter(Boolean));
}
function exportBenchSources(sourceDir, injectDir) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, promises_1.mkdir)(injectDir, { recursive: true });
        const entries = yield (0, promises_1.readdir)(sourceDir, { withFileTypes: true });
        for (const entry of entries) {
            if (!entry.isFile())
                continue;
            if (!entry.name.endsWith('.ts'))
                continue;
            if (entry.name === 'compare.ts')
                continue;
            yield (0, promises_1.copyFile)((0, path_1.resolve)(sourceDir, entry.name), (0, path_1.resolve)(injectDir, entry.name));
        }
    });
}
function injectBenchSources(injectDir, targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, promises_1.mkdir)(targetDir, { recursive: true });
        const entries = yield (0, promises_1.readdir)(injectDir, { withFileTypes: true });
        const injected = [];
        for (const entry of entries) {
            if (!entry.isFile())
                continue;
            if (!entry.name.endsWith('.ts'))
                continue;
            const dest = (0, path_1.resolve)(targetDir, entry.name);
            yield (0, promises_1.copyFile)((0, path_1.resolve)(injectDir, entry.name), dest);
            injected.push(`src/bench/${entry.name}`);
        }
        return injected;
    });
}
function cleanupInjectedSources(injected, tracked) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const relPath of injected) {
            if (tracked.has(relPath))
                continue;
            yield (0, promises_1.rm)((0, path_1.resolve)(relPath), { force: true });
        }
    });
}
function printUsage() {
    const message = `
Usage:
  node dist/bench/compare.js --base-ref <ref> --candidate-ref <ref> [options]

Options:
  --base-ref <ref>         Git ref for baseline (default HEAD~1)
  --candidate-ref <ref>    Git ref for candidate (default HEAD)
  --base-out <dir>         Output dir for baseline (default bench/outputs/baseline[-tag])
  --candidate-out <dir>    Output dir for candidate (default bench/outputs/candidate[-tag])
  --report-out <path>      Report output path (default bench/outputs/compare[-tag].csv)
  --report-format csv|json Report format (default csv)
  --tag <label>            Suffix for output dirs and report name
  --allow-dirty            Allow dirty working tree
  --bench-runner <path>    Path to bench runner JS (useful for older refs)
  --bench-reporter <path>  Path to bench report JS (useful for older refs)
  --no-inject-sources      Disable auto-injection of bench sources (injection is ON by default)
  --inject-dir <path>      Destination directory for injected sources

Examples:
  node dist/bench/compare.js --base-ref HEAD~1 --candidate-ref HEAD --mode fvecs --base bench/datasets/siftsmall_base.fvecs --query bench/datasets/siftsmall_query.fvecs --metric euclidean --bench-runner dist/bench/run.js --bench-reporter dist/bench/report.js

Passthrough to bench runner:
  --mode synthetic|fvecs
  --metric cosine|euclidean
  --base <path>
  --query <path>
  --limit <n>
  --query-limit <n>
  --count <n>
  --dim <n>
  --seed <n>
  --distribution uniform|gaussian
  --k <n>
  --efSearch <list>
  --M <list>
  --efConstruction <list>
`.trim();
    console.log(message);
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const argv = process.argv.slice(2);
        if (argv.includes('--help')) {
            printUsage();
            return;
        }
        let config = parseArgs(argv);
        ensureCleanWorkingTree(config.allowDirty);
        const originalRef = getCurrentRef();
        if (config.injectSources) {
            yield exportBenchSources((0, path_1.resolve)('src/bench'), config.injectDir);
        }
        try {
            checkout(config.baseRef);
            if (config.injectSources) {
                const tracked = getTrackedBenchFiles();
                if (tracked.size === 0) {
                    const injected = yield injectBenchSources(config.injectDir, (0, path_1.resolve)('src/bench'));
                    ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                    runBench(config.runScriptPath, config.runArgs, config.baseOut);
                    yield cleanupInjectedSources(injected, tracked);
                }
                else {
                    ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                    runBench(config.runScriptPath, config.runArgs, config.baseOut);
                }
            }
            else {
                ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                runBench(config.runScriptPath, config.runArgs, config.baseOut);
            }
            checkout(config.candidateRef);
            if (config.injectSources) {
                const tracked = getTrackedBenchFiles();
                if (tracked.size === 0) {
                    const injected = yield injectBenchSources(config.injectDir, (0, path_1.resolve)('src/bench'));
                    ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                    runBench(config.runScriptPath, config.runArgs, config.candidateOut);
                    yield cleanupInjectedSources(injected, tracked);
                }
                else {
                    ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                    runBench(config.runScriptPath, config.runArgs, config.candidateOut);
                }
            }
            else {
                ensureDistExists(config.runScriptPath, config.reportScriptPath, config.buildIfMissing);
                runBench(config.runScriptPath, config.runArgs, config.candidateOut);
            }
            runReport(config.reportScriptPath, config.baseOut, config.candidateOut, config.reportOut, config.reportFormat);
        }
        finally {
            if (originalRef) {
                checkout(originalRef);
            }
        }
    });
}
main().catch((err) => {
    console.error(err instanceof Error ? err.message : err);
    printUsage();
    process.exit(1);
});
