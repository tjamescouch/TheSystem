"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HNSWWithDB = void 0;
const main_1 = require("./main");
const idb_1 = require("idb");
const similarity_1 = require("./similarity");
class HNSWWithDB extends main_1.HNSW {
    constructor(M, efConstruction, dbName, efSearch = 50) {
        super(M, efConstruction, null, 'cosine', efSearch);
        this.db = null;
        this.dbName = dbName;
    }
    /**
     * Creates an IndexedDB-backed HNSW instance.
     */
    static create(M, efConstruction, dbName, efSearch = 50) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new HNSWWithDB(M, efConstruction, dbName, efSearch);
            yield instance.initDB();
            return instance;
        });
    }
    initDB() {
        return __awaiter(this, void 0, void 0, function* () {
            this.db = yield (0, idb_1.openDB)(this.dbName, 1, {
                upgrade(db) {
                    db.createObjectStore('hnsw-index');
                },
            });
        });
    }
    /**
     * Closes the current IndexedDB connection if open.
     */
    close() {
        if (!this.db) {
            return;
        }
        this.db.close();
        this.db = null;
    }
    /**
     * Persists the current graph to IndexedDB.
     */
    saveIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                throw new Error('Database is not initialized');
            }
            yield this.db.put('hnsw-index', this.toJSON(), 'hnsw');
        });
    }
    /**
     * Loads a persisted graph from IndexedDB if present.
     */
    loadIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                throw new Error('Database is not initialized');
            }
            const loadedHNSW = yield this.db.get('hnsw-index', 'hnsw');
            if (!loadedHNSW) {
                return;
            }
            // Update this HNSW instance with loaded data
            const hnsw = main_1.HNSW.fromJSON(loadedHNSW);
            this.M = hnsw.M;
            this.efConstruction = hnsw.efConstruction;
            this.efSearch = hnsw.efSearch;
            this.metric = hnsw.metric;
            this.d = hnsw.d;
            this.similarityFunction = hnsw.metric === 'cosine' ? similarity_1.cosineSimilarity : similarity_1.euclideanSimilarity;
            this.levelMax = hnsw.levelMax;
            this.entryPointId = hnsw.entryPointId;
            this.nodes = hnsw.nodes;
        });
    }
    /**
     * Deletes persisted graph data and re-initializes the backing DB.
     */
    deleteIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                throw new Error('Database is not initialized');
            }
            this.close();
            yield (0, idb_1.deleteDB)(this.dbName);
            yield this.initDB();
        });
    }
}
exports.HNSWWithDB = HNSWWithDB;
